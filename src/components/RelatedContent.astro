---
import { getCollection } from 'astro:content';
import { slug } from '../lib/utils';

interface Props {
  currentTags: string[];
  currentId: string;
  currentDate?: Date;
  contentType: 'blog' | 'projects' | 'gallery' | 'audio';
  limit?: number;
}

const { currentTags, currentId, currentDate, contentType, limit = 3 } = Astro.props;

// Gather all content types
const [blogs, projects, galleries, audios] = await Promise.all([
  getCollection('blog'),
  getCollection('projects'),
  getCollection('gallery').catch(() => []),
  getCollection('audio').catch(() => []),
]);

type ContentItem = {
  id: string;
  type: 'blog' | 'projects' | 'gallery' | 'audio';
  title: string;
  description: string;
  tags: string[];
  date: Date;
  href: string;
  score: number;
};

const allItems: ContentItem[] = [
  ...blogs
    .filter((p) => !p.data.draft)
    .map((p) => ({
      id: `blog:${p.id}`,
      type: 'blog' as const,
      title: p.data.title,
      description: p.data.description,
      tags: p.data.tags,
      date: p.data.date,
      href: `/blog/${slug(p.id)}/`,
      score: 0,
    })),
  ...projects.map((p) => ({
    id: `projects:${p.id}`,
    type: 'projects' as const,
    title: p.data.title,
    description: p.data.description,
    tags: p.data.tags,
    date: p.data.date,
    href: p.data.url || `/projects/${slug(p.id)}/`,
    score: 0,
  })),
  ...galleries.map((p) => ({
    id: `gallery:${p.id}`,
    type: 'gallery' as const,
    title: p.data.title,
    description: p.data.description || '',
    tags: p.data.tags,
    date: p.data.date,
    href: `/gallery/${slug(p.id)}/`,
    score: 0,
  })),
  ...audios.map((p) => ({
    id: `audio:${p.id}`,
    type: 'audio' as const,
    title: p.data.title,
    description: p.data.description,
    tags: p.data.tags,
    date: p.data.date,
    href: `/audio/${slug(p.id)}/`,
    score: 0,
  })),
];

// Build tag frequency map for IDF-style weighting (rare tags score higher)
const tagCounts = new Map<string, number>();
for (const item of allItems) {
  for (const t of item.tags) {
    tagCounts.set(t, (tagCounts.get(t) || 0) + 1);
  }
}
const totalItems = allItems.length;

// Temporal proximity: boost for content published near the same time
const NINETY_DAYS_MS = 90 * 24 * 60 * 60 * 1000;
const currentTime = currentDate?.getTime();

// Score by weighted tag overlap + temporal proximity
const related = allItems
  .filter((item) => item.id !== `${contentType}:${currentId}`)
  .map((item) => {
    // Tag co-occurrence score: shared tags weighted by inverse frequency
    const tagScore = item.tags
      .filter((t) => currentTags.includes(t))
      .reduce((sum, t) => sum + Math.log(totalItems / (tagCounts.get(t) || 1)), 0);

    // Temporal proximity: linear decay over 90 days, max 20% of tag score
    let temporalBoost = 0;
    if (currentTime && tagScore > 0) {
      const daysDiff = Math.abs(currentTime - item.date.getTime());
      if (daysDiff < NINETY_DAYS_MS) {
        temporalBoost = tagScore * 0.2 * (1 - daysDiff / NINETY_DAYS_MS);
      }
    }

    return { ...item, score: tagScore + temporalBoost };
  })
  .filter((item) => item.score > 0)
  .sort((a, b) => b.score - a.score)
  .slice(0, limit);

const typeLabels: Record<string, string> = {
  blog: 'Post',
  projects: 'Project',
  gallery: 'Gallery',
  audio: 'Audio',
};
---

{
  related.length > 0 && (
    <aside class="mt-12 border-t border-border pt-8" aria-label="Related content">
      <h3 class="mb-4 text-sm font-semibold uppercase tracking-wider text-text-muted">Related</h3>
      <div class="space-y-3">
        {related.map((item) => (
          <a href={item.href} class="group flex items-start gap-3 no-underline">
            <span class="mt-0.5 whitespace-nowrap rounded-full border border-border bg-surface-alt px-2 py-0.5 text-xs text-text-muted">
              {typeLabels[item.type]}
            </span>
            <span class="text-sm text-text transition-colors group-hover:text-accent">{item.title}</span>
          </a>
        ))}
      </div>
    </aside>
  )
}
